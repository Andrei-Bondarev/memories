{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isTemplatePartActive } from './template.js';\nconst walkerNodeFilter = 133\n/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\n\nexport function removeNodesFromTemplate(template, nodesToRemove) {\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template;\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode = null;\n\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode; // End removal if stepped past the removing node\n\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    } // A node to remove was found in the template\n\n\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node); // Track node we're removing\n\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    } // When removing, increment count by which to adjust subsequent part indices\n\n\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n\n  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));\n}\n\nconst countNodes = node => {\n  let count = node.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n\n  while (walker.nextNode()) {\n    count++;\n  }\n\n  return count;\n};\n\nconst nextActiveIndexInTemplateParts = function (parts) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n  for (let i = startIndex + 1; i < parts.length; i++) {\n    const part = parts[i];\n\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\n\n\nexport function insertNodeIntoTemplate(template, node) {\n  let refNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template; // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode;\n\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode.insertBefore(node, refNode);\n    }\n\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n\n        return;\n      }\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["isTemplatePartActive","walkerNodeFilter","removeNodesFromTemplate","template","nodesToRemove","element","content","parts","walker","document","createTreeWalker","partIndex","nextActiveIndexInTemplateParts","part","nodeIndex","removeCount","nodesToRemoveInTemplate","currentRemovingNode","nextNode","node","currentNode","previousSibling","has","push","undefined","index","forEach","n","parentNode","removeChild","countNodes","count","nodeType","startIndex","i","length","insertNodeIntoTemplate","refNode","appendChild","insertCount","walkerIndex","walkerNode","insertBefore"],"sources":["D:\\web\\Pet_Memories\\client\\my-app\\node_modules\\lit-html\\src\\lib\\modify-template.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isTemplatePartActive, Template, TemplatePart} from './template.js';\n\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nexport function removeNodesFromTemplate(\n    template: Template, nodesToRemove: Set<Node>) {\n  const {element: {content}, parts} = template;\n  const walker =\n      document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode: Node|null = null;\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode as Element;\n    // End removal if stepped past the removing node\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    }\n    // A node to remove was found in the template\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node);\n      // Track node we're removing\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    }\n    // When removing, increment count by which to adjust subsequent part indices\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n      // go to the next active part.\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n  nodesToRemoveInTemplate.forEach((n) => n.parentNode!.removeChild(n));\n}\n\nconst countNodes = (node: Node) => {\n  let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n  while (walker.nextNode()) {\n    count++;\n  }\n  return count;\n};\n\nconst nextActiveIndexInTemplateParts =\n    (parts: TemplatePart[], startIndex = -1) => {\n      for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(\n    template: Template, node: Node, refNode: Node|null = null) {\n  const {element: {content}, parts} = template;\n  // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n  const walker =\n      document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode as Element;\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode!.insertBefore(node, refNode);\n    }\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n        return;\n      }\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}