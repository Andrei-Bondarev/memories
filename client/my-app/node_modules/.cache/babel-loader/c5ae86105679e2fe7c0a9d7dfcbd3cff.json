{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\n\nexport class TemplateInstance {\n  constructor(template, processor, options) {\n    this.__parts = [];\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values) {\n    let i = 0;\n\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n\n      i++;\n    }\n\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone() {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);\n    const stack = [];\n    const parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\n    const walker = document.createTreeWalker(fragment, 133\n    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n    , null, false);\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part;\n    let node = walker.nextNode(); // Loop through all the nodes and parts of a template\n\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n\n        partIndex++;\n        continue;\n      } // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n\n\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n\n        if (node.nodeName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop();\n          node = walker.nextNode();\n        }\n      } // We've arrived at our part's node.\n\n\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node.previousSibling);\n\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n      }\n\n      partIndex++;\n    }\n\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n\n    return fragment;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isCEPolyfill","isTemplatePartActive","TemplateInstance","constructor","template","processor","options","update","values","i","part","__parts","undefined","setValue","commit","_clone","fragment","element","content","cloneNode","document","importNode","stack","parts","walker","createTreeWalker","partIndex","nodeIndex","node","nextNode","length","push","index","nodeName","currentNode","pop","type","handleTextExpression","insertAfterNode","previousSibling","handleAttributeExpressions","name","strings","adoptNode","customElements","upgrade"],"sources":["D:\\web\\Pet_Memories\\client\\my-app\\node_modules\\lit-html\\src\\lib\\template-instance.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isCEPolyfill} from './dom.js';\nimport {Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateProcessor} from './template-processor.js';\nimport {isTemplatePartActive, Template, TemplatePart} from './template.js';\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n  private readonly __parts: Array<Part|undefined> = [];\n  readonly processor: TemplateProcessor;\n  readonly options: RenderOptions;\n  readonly template: Template;\n\n  constructor(\n      template: Template, processor: TemplateProcessor,\n      options: RenderOptions) {\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values: readonly unknown[]) {\n    let i = 0;\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n      i++;\n    }\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone(): DocumentFragment {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n\n    const fragment = isCEPolyfill ?\n        this.template.element.content.cloneNode(true) as DocumentFragment :\n        document.importNode(this.template.element.content, true);\n\n    const stack: Node[] = [];\n    const parts = this.template.parts;\n    // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n    const walker = document.createTreeWalker(\n        fragment,\n        133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n        null,\n        false);\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part: TemplatePart;\n    let node = walker.nextNode();\n    // Loop through all the nodes and parts of a template\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n        partIndex++;\n        continue;\n      }\n\n      // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n        if (node!.nodeName === 'TEMPLATE') {\n          stack.push(node!);\n          walker.currentNode = (node as HTMLTemplateElement).content;\n        }\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop()!;\n          node = walker.nextNode();\n        }\n      }\n\n      // We've arrived at our part's node.\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node!.previousSibling!);\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(...this.processor.handleAttributeExpressions(\n            node as Element, part.name, part.strings, this.options));\n      }\n      partIndex++;\n    }\n\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n    return fragment;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}