{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = value => {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\nexport const isIterable = value => {\n  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\n\nexport class AttributeCommitter {\n  constructor(element, name, strings) {\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n\n    for (let i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n\n\n  _createPart() {\n    return new AttributePart(this);\n  }\n\n  _getValue() {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    const parts = this.parts; // If we're assigning an attribute via syntax like:\n    //    attr=\"${foo}\"  or  attr=${foo}\n    // but not\n    //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n    // then we don't want to coerce the attribute value into one long\n    // string. Instead we want to just return the value itself directly,\n    // so that sanitizeDOMValue can get the actual value rather than\n    // String(value)\n    // The exception is if v is an array, in which case we do want to smash\n    // it together into a string without calling String() on the array.\n    //\n    // This also allows trusted values (when using TrustedTypes) being\n    // assigned to DOM sinks without being stringified in the process.\n\n    if (l === 1 && strings[0] === '' && strings[1] === '') {\n      const v = parts[0].value;\n\n      if (typeof v === 'symbol') {\n        return String(v);\n      }\n\n      if (typeof v === 'string' || !isIterable(v)) {\n        return v;\n      }\n    }\n\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = parts[i];\n\n      if (part !== undefined) {\n        const v = part.value;\n\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit() {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue());\n    }\n  }\n\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\n\nexport class AttributePart {\n  constructor(committer) {\n    this.value = undefined;\n    this.committer = committer;\n  }\n\n  setValue(value) {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value; // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n\n    if (this.value === noChange) {\n      return;\n    }\n\n    this.committer.commit();\n  }\n\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\n\nexport class NodePart {\n  constructor(options) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  appendInto(container) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  insertAfterNode(ref) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling;\n  }\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  appendIntoPart(part) {\n    part.__insert(this.startNode = createMarker());\n\n    part.__insert(this.endNode = createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  insertAfterPart(ref) {\n    ref.__insert(this.startNode = createMarker());\n\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n\n    const value = this.__pendingValue;\n\n    if (value === noChange) {\n      return;\n    }\n\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n\n  __insert(node) {\n    this.endNode.parentNode.insertBefore(node, this.endNode);\n  }\n\n  __commitNode(value) {\n    if (this.value === value) {\n      return;\n    }\n\n    this.clear();\n\n    this.__insert(value);\n\n    this.value = value;\n  }\n\n  __commitText(value) {\n    const node = this.startNode.nextSibling;\n    value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n\n    const valueAsString = typeof value === 'string' ? value : String(value);\n\n    if (node === this.endNode.previousSibling && node.nodeType === 3\n    /* Node.TEXT_NODE */\n    ) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      node.data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n\n    this.value = value;\n  }\n\n  __commitTemplateResult(value) {\n    const template = this.options.templateFactory(value);\n\n    if (this.value instanceof TemplateInstance && this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance = new TemplateInstance(template, value.processor, this.options);\n\n      const fragment = instance._clone();\n\n      instance.update(value.values);\n\n      this.__commitNode(fragment);\n\n      this.value = instance;\n    }\n  }\n\n  __commitIterable(value) {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    } // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n\n\n    const itemParts = this.value;\n    let partIndex = 0;\n    let itemPart;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex]; // If no existing part, create a new one\n\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n\n  clear() {\n    let startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;\n    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n  }\n\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\n\nexport class BooleanAttributePart {\n  constructor(element, name, strings) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error('Boolean attributes can only contain a single expression');\n    }\n\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n\n    const value = !!this.__pendingValue;\n\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n\n      this.value = value;\n    }\n\n    this.__pendingValue = noChange;\n  }\n\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\n\nexport class PropertyCommitter extends AttributeCommitter {\n  constructor(element, name, strings) {\n    super(element, name, strings);\n    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';\n  }\n\n  _createPart() {\n    return new PropertyPart(this);\n  }\n\n  _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n\n    return super._getValue();\n  }\n\n  commit() {\n    if (this.dirty) {\n      this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.element[this.name] = this._getValue();\n    }\n  }\n\n}\nexport class PropertyPart extends AttributePart {} // Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\n\nlet eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.removeEventListener('test', options, options);\n  } catch (_e) {// event options not supported\n  }\n})();\n\nexport class EventPart {\n  constructor(element, eventName, eventContext) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n\n    this.__boundHandleEvent = e => this.handleEvent(e);\n  }\n\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);\n    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n    }\n\n    this.value = newListener;\n    this.__pendingValue = noChange;\n  }\n\n  handleEvent(event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      this.value.handleEvent(event);\n    }\n  }\n\n} // We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\n\nconst getOptions = o => o && (eventOptionsSupported ? {\n  capture: o.capture,\n  passive: o.passive,\n  once: o.once\n} : o.capture);","map":{"version":3,"mappings":"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","names":["isDirective","removeNodes","noChange","nothing","TemplateInstance","TemplateResult","createMarker","isPrimitive","value","isIterable","Array","isArray","Symbol","iterator","AttributeCommitter","constructor","element","name","strings","parts","i","length","_createPart","AttributePart","_getValue","l","v","String","text","part","undefined","t","commit","dirty","setAttribute","committer","setValue","directive","NodePart","options","appendInto","container","startNode","appendChild","endNode","insertAfterNode","ref","nextSibling","appendIntoPart","__insert","insertAfterPart","__pendingValue","parentNode","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","node","insertBefore","valueAsString","previousSibling","nodeType","data","document","createTextNode","template","templateFactory","update","values","instance","processor","fragment","_clone","itemParts","partIndex","itemPart","item","push","BooleanAttributePart","Error","removeAttribute","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","window","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","__boundHandleEvent","e","handleEvent","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","getOptions","event","call","o"],"sources":["D:\\web\\Pet_Memories\\client\\my-app\\node_modules\\lit-html\\src\\lib\\parts.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {isDirective} from './directive.js';\nimport {removeNodes} from './dom.js';\nimport {noChange, nothing, Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {createMarker} from './template.js';\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\nexport type Primitive = null|undefined|boolean|number|string|symbol|bigint;\nexport const isPrimitive = (value: unknown): value is Primitive => {\n  return (\n      value === null ||\n      !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value: unknown): value is Iterable<unknown> => {\n  return Array.isArray(value) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      !!(value && (value as any)[Symbol.iterator]);\n};\n\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: ReadonlyArray<string>;\n  readonly parts: ReadonlyArray<AttributePart>;\n  dirty = true;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      (this.parts as AttributePart[])[i] = this._createPart();\n    }\n  }\n\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  protected _createPart(): AttributePart {\n    return new AttributePart(this);\n  }\n\n  protected _getValue(): unknown {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    const parts = this.parts;\n\n    // If we're assigning an attribute via syntax like:\n    //    attr=\"${foo}\"  or  attr=${foo}\n    // but not\n    //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n    // then we don't want to coerce the attribute value into one long\n    // string. Instead we want to just return the value itself directly,\n    // so that sanitizeDOMValue can get the actual value rather than\n    // String(value)\n    // The exception is if v is an array, in which case we do want to smash\n    // it together into a string without calling String() on the array.\n    //\n    // This also allows trusted values (when using TrustedTypes) being\n    // assigned to DOM sinks without being stringified in the process.\n    if (l === 1 && strings[0] === '' && strings[1] === '') {\n      const v = parts[0].value;\n      if (typeof v === 'symbol') {\n        return String(v);\n      }\n      if (typeof v === 'string' || !isIterable(v)) {\n        return v;\n      }\n    }\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue() as string);\n    }\n  }\n}\n\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart implements Part {\n  readonly committer: AttributeCommitter;\n  value: unknown = undefined;\n\n  constructor(committer: AttributeCommitter) {\n    this.committer = committer;\n  }\n\n  setValue(value: unknown): void {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart implements Part {\n  readonly options: RenderOptions;\n  startNode!: Node;\n  endNode!: Node;\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(options: RenderOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container: Node) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref: Node) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling!;\n  }\n\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part: NodePart) {\n    part.__insert(this.startNode = createMarker());\n    part.__insert(this.endNode = createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref: NodePart) {\n    ref.__insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n\n  private __insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private __commitNode(value: Node): void {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n\n  private __commitText(value: unknown): void {\n    const node = this.startNode.nextSibling!;\n    value = value == null ? '' : value;\n    // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n    const valueAsString: string =\n        typeof value === 'string' ? value : String(value);\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      (node as Text).data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n\n  private __commitTemplateResult(value: TemplateResult): void {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance &&\n        this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance =\n          new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n\n  private __commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value as NodePart[];\n    let partIndex = 0;\n    let itemPart: NodePart|undefined;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart implements Part {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: readonly string[];\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(element: Element, name: string, strings: readonly string[]) {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n          'Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = noChange;\n  }\n}\n\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  readonly single: boolean;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    super(element, name, strings);\n    this.single =\n        (strings.length === 2 && strings[0] === '' && strings[1] === '');\n  }\n\n  protected _createPart(): PropertyPart {\n    return new PropertyPart(this);\n  }\n\n  protected _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.element as any)[this.name] = this._getValue();\n    }\n  }\n}\n\nexport class PropertyPart extends AttributePart {}\n\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.addEventListener('test', options as any, options);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.removeEventListener('test', options as any, options);\n  } catch (_e) {\n    // event options not supported\n  }\n})();\n\ntype EventHandlerWithOptions =\n    EventListenerOrEventListenerObject&Partial<AddEventListenerOptions>;\nexport class EventPart implements Part {\n  readonly element: Element;\n  readonly eventName: string;\n  readonly eventContext?: EventTarget;\n  value: undefined|EventHandlerWithOptions = undefined;\n  private __options?: AddEventListenerOptions;\n  private __pendingValue: undefined|EventHandlerWithOptions = undefined;\n  private readonly __boundHandleEvent: (event: Event) => void;\n\n  constructor(element: Element, eventName: string, eventContext?: EventTarget) {\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = (e) => this.handleEvent(e);\n  }\n\n  setValue(value: undefined|EventHandlerWithOptions): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange as EventHandlerWithOptions;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null ||\n        oldListener != null &&\n            (newListener.capture !== oldListener.capture ||\n             newListener.once !== oldListener.once ||\n             newListener.passive !== oldListener.passive);\n    const shouldAddListener =\n        newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    this.value = newListener;\n    this.__pendingValue = noChange as EventHandlerWithOptions;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      (this.value as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o: AddEventListenerOptions|undefined) => o &&\n    (eventOptionsSupported ?\n         {capture: o.capture, passive: o.passive, once: o.once} :\n         o.capture as AddEventListenerOptions);\n"]},"metadata":{},"sourceType":"module"}